#!/usr/bin/env bash
set -euo pipefail

out_dir="${RELEASE_SCORECARD_OUT_DIR:-target/release-scorecard}"
bench_report="${BENCH_BUDGET_REPORT_PATH:-target/criterion/bench-budget-report.txt}"
soak_report="${SOAK_REPORT_PATH:-target/soak/soak-report.json}"
provenance_report="${PROVENANCE_REPORT_PATH:-target/supply-chain/provenance/artifact-provenance.json}"
security_checklist="${SECURITY_REVIEW_CHECKLIST_PATH:-docs/runbooks/security-review-checklist.md}"
max_soak_failures="${SCORECARD_MAX_SOAK_FAILURES:-0}"

fail() {
  echo "release-scorecard failed: $*" >&2
  exit 1
}

require_file() {
  local path="$1"
  [ -f "$path" ] || fail "required file missing: $path"
}

require_command() {
  local cmd="$1"
  command -v "$cmd" >/dev/null || fail "required command missing: $cmd"
}

grep_value() {
  local pattern="$1"
  local file="$2"
  grep -nE "$pattern" "$file" | tail -n1 | awk '{print $2}'
}

if command -v rg >/dev/null; then
  grep_perf_status() {
    rg -n "^Status:\\s+[A-Z]+$" "$bench_report" | tail -n1 | awk '{print $2}'
  }

  count_pass_rows() {
    rg -c "\\| PASS \\|" "$security_checklist" || true
  }
else
  grep_perf_status() {
    grep_value '^Status:[[:space:]]+[A-Z]+$' "$bench_report"
  }

  count_pass_rows() {
    grep -cF "| PASS |" "$security_checklist" || true
  }
fi

require_command jq
require_file "$bench_report"
require_file "$soak_report"
require_file "$provenance_report"
require_file "$security_checklist"

mkdir -p "$out_dir"

perf_status="$(grep_perf_status)"
[ -n "$perf_status" ] || fail "unable to read performance status from $bench_report"

soak_status="$(jq -r '.status // "unknown"' "$soak_report")"
soak_failures="$(jq -r '.total_failures // 0' "$soak_report")"
soak_mesh_failures="$(jq -r '.mesh_failures // 0' "$soak_report")"
soak_duration_secs="$(jq -r '.duration_secs // 0' "$soak_report")"
soak_timestamp="$(jq -r '.timestamp_utc // ""' "$soak_report")"

artifact_count="$(jq -r '.artifacts | length' "$provenance_report")"
git_commit="$(jq -r '.git_commit // "unknown"' "$provenance_report")"
generated_at_unix_secs="$(jq -r '.generated_at_unix_secs // 0' "$provenance_report")"

security_pass_rows="$(count_pass_rows)"
security_pass_rows="${security_pass_rows:-0}"

overall_status="PASS"
if [ "$perf_status" != "PASS" ] || [ "$soak_status" != "pass" ] || [ "$soak_failures" -gt "$max_soak_failures" ]; then
  overall_status="FAIL"
fi

json_path="$out_dir/release-scorecard.json"
markdown_path="$out_dir/release-scorecard.md"

cat > "$json_path" <<EOF
{
  "overall_status": "$overall_status",
  "performance_status": "$perf_status",
  "soak_status": "$soak_status",
  "soak_failures": $soak_failures,
  "soak_mesh_failures": $soak_mesh_failures,
  "max_soak_failures": $max_soak_failures,
  "soak_duration_secs": $soak_duration_secs,
  "soak_timestamp_utc": "$soak_timestamp",
  "supply_chain_artifact_count": $artifact_count,
  "security_pass_rows": $security_pass_rows,
  "git_commit": "$git_commit",
  "provenance_generated_at_unix_secs": $generated_at_unix_secs
}
EOF

cat > "$markdown_path" <<EOF
# Release Scorecard

Generated by \`tools/scripts/release-scorecard.sh\`.

## Summary

| Metric | Value |
| --- | --- |
| Overall status | \`$overall_status\` |
| Performance budget status | \`$perf_status\` |
| Soak status | \`$soak_status\` |
| Soak failures | \`$soak_failures\` |
| Mesh failures | \`$soak_mesh_failures\` |
| Soak duration (secs) | \`$soak_duration_secs\` |
| Soak timestamp (UTC) | \`$soak_timestamp\` |
| Supply-chain artifact count | \`$artifact_count\` |
| Security checklist PASS rows | \`$security_pass_rows\` |
| Provenance git commit | \`$git_commit\` |
| Provenance generated_at_unix_secs | \`$generated_at_unix_secs\` |

## Inputs

- Bench budget report: \`$bench_report\`
- Soak report: \`$soak_report\`
- Provenance report: \`$provenance_report\`
- Security checklist: \`$security_checklist\`

## Trend Guidance

Store this file as a CI artifact per release candidate and compare \`overall_status\`,
\`performance_status\`, \`soak_failures\`, and \`security_pass_rows\` across releases.
EOF

echo "release-scorecard generated:"
echo "  - $markdown_path"
echo "  - $json_path"
