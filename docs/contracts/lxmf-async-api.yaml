version: 0.2
name: LXMF Async Client Contract
status: draft
last_updated: 2026-02-09

goal: |
  Define a backend-neutral async contract for LXMF clients so the same client and
  the same tests can run against both Python LXMF and Rust lxmf-rs adapters.

non_goals:
  - Expose raw backend method names as the primary interface.
  - Guarantee identical internal queueing/retry internals across backends.
  - Replace backend-specific advanced APIs.

design_principles:
  - contract_not_mirror: |
      Contract describes behavior and outcomes. Backend methods are only listed in
      adapter mappings.
  - tick_driven_execution: |
      Delivery progress is advanced by explicit service ticks. Adapters may run ticks
      in a background task, but deterministic tests should call tick directly.
  - explicit_capabilities: |
      Clients must negotiate optional features instead of assuming backend parity.
  - event_first_observability: |
      Progress and terminal outcomes are observable through events and status polling.

capabilities:
  required:
    - outbound.send
    - outbound.cancel
    - outbound.status
    - service.tick
    - events.outbound
  optional:
    - inbound.receive
    - outbound.delivery_methods.direct
    - outbound.delivery_methods.opportunistic
    - outbound.delivery_methods.propagated
    - outbound.delivery_methods.paper
    - propagation.fetch
    - policy.auth_required
    - policy.allow_deny_ignore_prioritise

types:
  delivery_method:
    enum:
      - opportunistic
      - direct
      - propagated
      - paper

  outbound_state:
    enum:
      - queued
      - sending
      - sent
      - delivered
      - rejected
      - failed
      - cancelled
      - deferred
    terminal:
      - delivered
      - rejected
      - failed
      - cancelled

  message_input:
    fields:
      destination: bytes[16] or backend destination object
      source: bytes[16] or backend source object
      content: bytes|string
      title: optional bytes|string
      fields: optional map
      method: delivery_method
      include_ticket: optional bool
      stamp_cost: optional int

  message_handle:
    fields:
      id: bytes|string
      created_at: unix_seconds

  outbound_status:
    fields:
      handle: message_handle
      state: outbound_state
      progress: int (0..100)
      updated_at: unix_seconds
      detail: optional string

  event:
    fields:
      type: enum
      emitted_at: unix_seconds
      data: map
    supported_types:
      - outbound.progress
      - outbound.terminal
      - inbound.received
      - service.warning
      - service.error

contract:
  session:
    create:
      summary: Create a client session bound to one backend adapter.
      params:
        storage_path: required path
        adapter_config: optional map
      returns: session

    capabilities:
      summary: Query capability flags before using optional API features.
      returns:
        - list of capability strings

    close:
      summary: Stop background tasks and release backend resources.
      returns: bool

  outbound:
    send:
      summary: Queue a message for async delivery.
      params:
        message: message_input
      returns: message_handle
      guarantees:
        - handle is stable for subsequent status and cancel calls
        - initial status is queued or deferred

    cancel:
      summary: Cancel a queued or in-flight outbound message.
      params:
        handle: message_handle
        reason: optional string
      returns: bool
      guarantees:
        - if true, eventual terminal state is cancelled

    status:
      summary: Query latest known status for a message handle.
      params:
        handle: message_handle
      returns: outbound_status or null

  inbound:
    register_handler:
      summary: Register callback for inbound message events.
      params:
        handler: function(event)
      returns: handler_id
      requires:
        - inbound.receive

    unregister_handler:
      summary: Remove previously registered inbound handler.
      params:
        handler_id: string|int
      returns: bool
      requires:
        - inbound.receive

  service:
    tick:
      summary: Run one service cycle that advances queues and maintenance.
      params:
        max_outbound: optional int default=1
        now: optional unix_seconds
      returns:
        outbound_processed: int
        inbound_processed: int
        maintenance_ran: bool

    run_background:
      summary: Start periodic ticking in a background task/thread.
      params:
        interval_ms: int
      returns: bool

    stop_background:
      summary: Stop periodic background ticking.
      returns: bool

  events:
    poll:
      summary: Pull pending events from the adapter event queue.
      params:
        max_items: optional int default=100
      returns:
        - event

    semantics:
      outbound_progress:
        type: outbound.progress
        data:
          handle: message_handle
          progress: int (0..100)
      outbound_terminal:
        type: outbound.terminal
        data:
          handle: message_handle
          state: delivered|rejected|failed|cancelled
          detail: optional string
      inbound_received:
        type: inbound.received
        data:
          message: backend-normalized inbound payload

extensions:
  policy:
    set_auth_required:
      params:
        required: bool
      requires:
        - policy.auth_required
    allow_destination:
      params:
        destination: bytes[16]
      requires:
        - policy.allow_deny_ignore_prioritise
    deny_destination:
      params:
        destination: bytes[16]
      requires:
        - policy.allow_deny_ignore_prioritise
    ignore_destination:
      params:
        destination: bytes[16]
      requires:
        - policy.allow_deny_ignore_prioritise
    prioritise_destination:
      params:
        destination: bytes[16]
      requires:
        - policy.allow_deny_ignore_prioritise

  propagation:
    enable:
      params:
        store_root: path
        target_cost: int
    ingest:
      params:
        bytes: wire bytes
      returns:
        ingested_count: int
    fetch:
      params:
        transient_id: bytes
      returns:
        wire bytes
      requires:
        - propagation.fetch

  paper:
    ingest_uri:
      params:
        uri: string
      returns:
        destination: bytes[16]
        transient_id: bytes
        duplicate: bool
        bytes_len: int

conformance_requirements:
  - outbound status transitions are monotonic
  - every sent handle reaches a terminal state unless explicitly deferred
  - progress stays within 0..100 and never decreases
  - cancel(true) is followed by outbound.terminal(cancelled)
  - event order is causal per handle (progress before terminal)

adapter_bindings:
  python_lxmf:
    notes:
      - Uses LXMRouter callback/event behavior with adapter-side normalization.
      - Adapter may need internal polling for progress when backend lacks a direct callback.
    mappings:
      outbound.send:
        - build LXMF.LXMessage
        - call router.handle_outbound(message)
      outbound.cancel:
        - call router.cancel_outbound(message_id) when available in backend/runtime
      inbound.register_handler:
        - call router.register_delivery_callback(callback)
      service.tick:
        - call router.jobs() when available
      paper.ingest_uri:
        - call router.ingest_lxm_uri(uri)

  rust_lxmf_rs:
    notes:
      - Current router is queue-first: enqueue then process.
      - Status/progress events are adapter-derived from Router results/callbacks.
    mappings:
      outbound.send:
        - call Router.enqueue_outbound(message)
        - return message_id as handle
      outbound.cancel:
        - call Router.cancel_outbound(handle.id)
      outbound.status:
        - call Router.outbound_progress(handle.id)
      service.tick:
        - call Router.handle_outbound(max_outbound)
        - call Router.jobs()
      policy.set_auth_required:
        - call Router.set_auth_required(required)
      policy.allow_destination:
        - call Router.allow_destination(destination)
      policy.deny_destination:
        - call Router.deny_destination(destination)
      policy.ignore_destination:
        - call Router.ignore_destination(destination)
      policy.prioritise_destination:
        - call Router.prioritise_destination(destination)
      propagation.enable:
        - call Router.enable_propagation(store_root, target_cost)
      propagation.ingest:
        - call Router.ingest_propagation(bytes)
      propagation.fetch:
        - call Router.fetch_propagated(transient_id)
      paper.ingest_uri:
        - call Router.ingest_lxm_uri(uri)

test_harness:
  scenario_file_format: |
    Scenarios should be backend-agnostic fixtures (input message, policy setup,
    tick cadence, expected terminal state, expected events).
  execution_matrix:
    - python -> python
    - python -> rust
    - rust -> python
    - rust -> rust
  companion_doc: docs/async-conformance-matrix.md
